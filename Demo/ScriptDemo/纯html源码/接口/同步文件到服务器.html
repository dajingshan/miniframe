<%@//Script头、过程和函数定义
program codes;
%>

<%!//声明变量
var 
  ToPath, RelativePath, FileName, OldPath, ErrStr, TmpPath: string;
  Json: TminiJson;
  Ms: TMemoryStream;
  Fs: TFileStream;
  SL: TStringlist;
  lp: integer;
function GetOneDirFileInfo(Json: TminiJson; Path: string): string;
var
  Status: Integer;
  SearchRec: TSearchRec;
  json_sub: TminiJson;
begin
  Path := PathWithSlash(Path);
  SearchRec := TSearchRec.Create;
  Status := FindFirst(Path + '*.*', faAnyFile, SearchRec);
  try
    while Status = 0 do
    begin 
      if SearchRec.Attr and faDirectory = faDirectory then
      begin
        if (SearchRec.name <> '.') and (SearchRec.name <> '..') then
        begin
          FileName := Path + SearchRec.Name;
          json_sub := Pub.GetJson;  
          json_sub.SO; //初始化 或 json.Init;    
          json_sub.S['isdir'] := '1';
          json_sub.S['filename'] := FileName;
          json_sub.S['RelativePath'] := GetDeliBack(FileName, OldPath);
          json_sub.S['FileTime'] := '';
          json_sub.I['size'] := 0;
          json.A['list'] := json_sub; 
          
          GetOneDirFileInfo(Json, Path + SearchRec.Name + '\');
        end;
      end else
      begin
        FileName := Path + SearchRec.Name;
        try
          if FileExists(FileName) and (Pos('@_', SearchRec.Name) < 1) then
          begin 
            json_sub := Pub.GetJson;  
            json_sub.SO; //初始化 或 json.Init;    
            json_sub.S['isdir'] := '0';
            json_sub.S['filename'] := SearchRec.name;
            json_sub.S['RelativePath'] := GetDeliBack(FileName, OldPath);
            json_sub.S['FileTime'] := FileGetFileTimeA(FileName);
            json_sub.I['size'] := SearchRec.Size;
            json.A['list'] := json_sub;
          end;
        except
          //print(ExceptionParam)
        end;//}
      end; 
      Status := FindNext(SearchRec);
    end;
  finally
    FindClose(SearchRec);
    SearchRec.Free;
  end;//*) 
end;
%>
<%
begin

  Response.ContentType := 'application/json;charset=UTF-8'; //返回的数据类型
  json := Pub.GetJson; //这样创建json对象不需要自己释放，系统自动管理
  json.SO;
  json.S['retcode'] := '100';

  ToPath := 'D:\同步测试\服务上';
  {// 验证是否登录代码
  if not Request.IsLogin('Logined') then
  begin 
    json.S['retcode'] := '300';
    json.S['retmsg'] := '你还没有登录(no logined)！'; 
    print(json.AsJson(true));
    exit; 
  end;//} 

  ToPath := PathWithSlash(ToPath);
  OldPath := ToPath;
  RelativePath := Request.V('fn');
  TmpPath := FileGetTemporaryPath;   // ToPath;//
  FileName := TmpPath + RelativePath;
  if Request.V('opr') = '1' then
  begin //获取服务上指定目录的文件信息
    json.S['retcode'] := '200'; 
    json.S['retmsg'] := '获取文件表成功！';
    GetOneDirFileInfo(Json, OldPath);
    print(json.AsJson(true)); 
  end else
  if Request.V('opr') = '2' then
  begin //删除文件
    DeleteFile(ToPath + RelativePath);
    json.S['retcode'] := '200'; 
    json.S['retmsg'] := '文件【' + RelativePath + '】已删除!'; 
    print(json.AsJson(true));
  end else 
  if Request.V('opr') = '6' then //判断是否已存在文件，续点传输
  begin   
    if FileExists(ToPath + Request.V('newfn')) then
    begin
      SL := Pub.GetSL;
      SL.LoadFromFile(ToPath + Request.V('newfn'));
      json.S['pos'] := trim(SL.Text);
      json.S['retcode'] := '210';
      json.S['retmsg'] := '文件【' + RelativePath + '】已存在!'; 
    end else
    begin
      json.S['retcode'] := '200'; 
      json.S['retmsg'] := '文件【' + RelativePath + '】不存在!';
    end;
    print(json.AsJson(true)); 
  end else
  if (Request.V('opr') = '3') or (Request.V('opr') = '5') then
  begin //接收上传文件
    Request.PostStream.Position := 0;
    //ForceDirectories(ExtractFilePath(FileName));
    //Request.PostStream.Savetofile(ToPath + Request.V('pos'));
    if lastError <> '' then 
    begin
      json.S['retmsg'] := lastError;
      print(json.AsJson(true));  
      exit;  
    end;

    FileName := ToPath + Request.V('oldfn');
    if (Request.V('opr') = '5') and (Request.V('Num') = '1') then
    begin
      DeleteFile(FileName);
      Fs := Pub.GetFS(FileName, fmCreate, ErrStr);
      if ErrStr <> '' then 
      begin
        json.S['retmsg'] := ErrStr;
        print(json.AsJson(true));  
        exit;  
      end;
    end else
    begin                                        
      Fs := Pub.GetFS(FileName, fmOpenWrite, ErrStr);
      if ErrStr <> '' then 
      begin
        json.S['retmsg'] := ErrStr;
        print(json.AsJson(true));  
        exit;  
      end;             
    end;
    Fs.Position := StrToInt64(Request.V('pos')); // Fs.Size;
    Fs.CopyFrom(Request.PostStream, Request.PostStream.Size);  
    
    SL := Pub.GetSL;
    SL.Text := Request.V('Num');
    SL.SaveToFile(ToPath + Request.V('newfn'));

    //修改文件时间 filetime
         
      
    if (Request.V('opr') = '3') or (Request.V('opr') = '5') and (Request.V('isend') = '1') then
    begin
      Fs.Free;
      Sleep(10);
      FileChangeFileDate(FileName, Request.V('filetime'));
      DeleteFile(ToPath + Request.V('newfn'));;
    end;
    json.S['retcode'] := '200'; 
    json.S['retmsg'] := '文件【' + RelativePath + '】已保存至服务器上!'; 
    print(json.AsJson(true));
  end else
  if Request.V('opr') = '4' then
  begin //删除文件夹
    RemoveDir(ToPath + RelativePath);
    json.S['retcode'] := '200'; 
    json.S['retmsg'] := '文件【' + RelativePath + '】已删除!'; 
    print(json.AsJson(true));
  end else 
  begin
    json.S['retcode'] := '300';
    json.S['retmsg'] := '调用参数不正确！';
    print(json.AsJson(true));
    exit;  
  end;
end;
%>
